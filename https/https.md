
### TCP、UDP、HTTP

##### HTTP（超文本传输协议）
+ 层次：应用层协议
+ 功能：HTTP用于在Web浏览器和服务器之间传输超文本数据（如HTML文件）。它定义了数据的格式和传输方式。
+ 特性：HTTP是一个无状态的请求/响应协议，每次请求都是独立的。

##### TCP（传输控制协议）
+ 层次：传输层协议
+ 功能：TCP提供可靠的、面向连接的通信。它确保数据包按顺序到达，并且没有丢失或重复。
+ 特性：TCP提供错误检测、流量控制和拥塞控制机制。它建立连接（三次握手）和断开连接（四次挥手）。

##### UDP（用户数据报协议）
+ 层次：传输层协议
+ 功能：UDP提供无连接的、不可靠的数据传输。适用于需要快速传输、对丢包不敏感的应用。
+ 特性：UDP没有建立连接的过程，也没有保证数据包顺序和完整性的机制。它的开销比TCP低，适用于实时应用（如视频流、游戏等）。
#####  关系和工作流程
1. 层次关系：HTTP位于应用层，TCP和UDP位于传输层。TCP和UDP是并列关系，但它们可以分别为应用层协议（如HTTP、DNS、DHCP等）提供服务。

2. HTTP和TCP的关系：HTTP通常使用TCP作为传输协议，因为HTTP需要可靠的数据传输。HTTP请求和响应的数据通过TCP连接传输，这保证了数据的完整性和顺序。
    + 工作流程：客户端发起HTTP请求 -> HTTP数据打包在TCP段中 -> TCP通过IP层传输数据 -> 服务器接收并解包TCP段中的HTTP数据 -> 服务器处理请求并返回响应。
3. UDP的使用场景：HTTP通常不使用UDP，因为UDP不保证数据传输的可靠性。然而，有些应用层协议（如DNS、VoIP、视频流等）使用UDP，因为它们需要低延迟和快速传输，即使这意味着可能会有数据包丢失。

##### 总结：

+ HTTP依赖于TCP来提供可靠的数据传输。
+ TCP和UDP是两种不同的传输层协议，各有适用场景。
+ HTTP作为一种应用层协议，通常使用TCP，而不是UDP。
>TCP和UDP都工作在传输层，目标都是在程序之间传递数据（文本、视频、图片）。对于两种协议都是二进制数据，并无区别

+ TCP：类似写信（对方是否能收到、收到的信是否完整、多封信顺序是否正确），数据包之间没有状态联系
+ UDP：类似于打电话，先建立连接，在传输数据
tcp通过三次握手、传输确认、四次挥手来保证传输的稳定性


##### TCP
###### 三次握手建立连接
![avatar](./threeHand.png)

>1.为什么需要三次握手而不是两次呢？
&emsp; 防止已失效的报文SYN又传输到服务器，导致服务端认为客户端又发起了一个新的连接。
2.如何保证数据的完整性和顺序?
&emsp; 服务端发送数据：通过分割报文，并给报文添加索引和长度
&emsp; 客户端收到数据：ACK = 索引 + 长度，将ACK返回服务端，这就是下一包数据的序列号
![avatar](./ACK.png)


###### 四次挥手：
![avatar](./fourHand.png)

>为什么需要超时等待?
&emsp; 服务端没收到ack包，会一直处于等待关闭状态。为了解决这个问题，服务端未收到ack时，会重新发送fin包，客户端收到fin包重新发送ack并重置超时等待时间

---

### HTTPS
![avatar](./https.png)

###### https是什么?
###### 加密原理和证书?
###### SSL/TSL握手过程?

<!-- 首先还是http一样的三次握手，建立tcp连接：
三次握手成功以后，
客户端想服务器发起一个请求，告诉服务端支持的TLS版本和支持的加密套件（也就是不同的加密算法），并生成一个随机数给服务端

服务器响应：在响应报文中告诉客户端自身支持的TLS版本和加密套件，并且也生成一个随机数给客户端

服务器再发一个响应把自己的证书给客户端，以便于客户端在整数的信任列表确认当前服务器是否可信，
把公钥发送给客户端
发请求告诉客户端我的响应结束了


客户端生成第三个随机数（预主密钥），用服务端的公钥加密预主密钥并发送给服务端

客户端：tsl协商结束

服务端：tsl协商结束 -->

> 三次握手结束后，通过非对称加密计算会话密钥，通过对称加密进行数据传输
##### 非对称加密：
1.客户端发起请求：
  + 支持的TSL协议版本
  + 支持的加密套件（加密算法）
  + 生成一个随机数

2.服务端：
 + 确认支持的TLS版本
 + 确认支持的加密套件
 + 生成一个随机数给客户端
 + 证书
 + 公钥

3.客户端：
 + 生成第三个随机数（预主密钥）
 + 用服务端公钥加密预主密钥并发送给服务端

4.服务端：
 + 私钥解密加密后的预主密钥，得到预主密钥
##### 对称加密(会话密钥)：
客户端和服务端分别计算，但结果相同
会话密钥 = 第一随机数+第二随机数+预主密钥