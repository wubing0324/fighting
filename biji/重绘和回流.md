重绘与回流
回流：修改了dom元素的位置与大小，导致布局发生变化
重绘：由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘。

回流触发时机
页面渲染初始化。
调整窗口大小。
改变字体，比如修改网页默认字体。
增加或者移除样式表。
内容变化，比如文本改变或者图片大小改变而引起的计算值宽度和高度改变。
内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代
页面一开始渲染的时候（这避免不了）
激活 CSS 伪类，激活 :hover 伪类本身不会自动触发整个页面的回流（reflow），除非 :hover 伪类的应用导致了影响布局的属性发生变化，
操作 class 属性。
脚本操作 DOM，增加删除或者修改 DOM 节点，元素尺寸改变——边距、填充、边框、宽度和高度。
设置 style 属性的值。
元素的位置发生变化
元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）

全局回流：
1. 调整浏览器窗口大小
浏览器窗口的大小变化会导致所有元素重新计算它们的布局，特别是在响应式设计中，各个元素的宽高、位置可能会随窗口的尺寸变化而调整。
2. 修改影响布局的 CSS 属性
改变某些会影响布局的属性，例如：
width, height, padding, border, margin
position、top、left、right、bottom
display（例如从 none 变为 block 或反之）
overflow, float, clear
font-size, line-height 这些属性的变化可能导致大量元素的重新布局，进而触发整个页面的回流。
3. 插入或删除 DOM 元素
动态添加、删除、或移动 DOM 元素可能引起其父元素及兄弟元素的布局变化，特别是对于流布局（block、inline）和复杂布局（如 flex 和 grid），可能会导致大范围的回流。
4. 改变元素的内容
当一个元素的内容发生变化，例如插入文本、调整文本内容等，可能会导致该元素的尺寸变化，并进一步影响其父元素及其后续的兄弟元素，从而引发回流。
5. 读取某些属性
读取与布局相关的属性会强制浏览器进行一次同步回流，以确保这些属性的值是最新的。常见的属性包括：
offsetWidth, offsetHeight, clientWidth, clientHeight
scrollTop, scrollLeft, scrollWidth, scrollHeight
getComputedStyle() 当读取这些属性时，浏览器必须重新计算元素的尺寸和布局，以确保返回正确的值。
6. 调整页面的字体
改变页面的字体大小或样式可能会导致文本的重新排版，从而影响页面的布局，进而触发回流。
7. 激活 CSS 动画或过渡
如果动画或过渡涉及改变影响布局的属性（如宽高、边距等），则每一帧的变化都会引发回流。
8. 表单元素样式改变
改变表单元素（如输入框、按钮）的尺寸或边框等样式，可能会导致表单布局或其他页面元素的变化，从而触发回流。
9. 使用 JavaScript 直接修改样式
通过 JavaScript 动态修改 CSS 样式或添加内联样式，尤其是涉及布局相关的属性时，会引发回流。
10. 计算滚动条的出现或消失
当页面或容器内的内容增加或减少导致滚动条的出现或消失时，可能会引发布局的重新计算，尤其是页面宽高因此发生变化时，回流会涉及整个页面。

如何减少回流？
批量修改 DOM：尽量减少频繁的 DOM 操作，批量进行多项修改。
使用 class 代替逐个修改样式：将样式变化整合到一个 class，然后通过添加或删除该 class 来减少回流的次数。
避免频繁读取布局信息：尽量减少同时读取和修改布局相关的属性，避免反复触发回流。
使用 documentFragment：在操作大量 DOM 元素时，可以先将它们添加到 documentFragment 中，再一次性插入页面。

offsetTop、offsetLeft、offsetWidth、offsetHeight
scrollTop、scrollLeft、scrollWidth、scrollHeight
clientTop、clientLeft、clientWidth、clientHeight
width、height
getComputedStyle()
getBoundingClientRect()

这些属性有一个共性，就是需要通过即时计算得到。因此浏览器为了获取这些值，也会进行回流

减少重绘与回流
CSS

使用 transform 替代 top

使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局

避免使用table布局，可能很小的一个小改动会造成整个 table 的重新布局。

尽可能在DOM树的最末端改变class，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。

避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多。

<div>
  <a> <span></span> </a>
</div>
<style>
  span {
    color: red;
  }
  div > a > span {
    color: red;
  }
</style>
对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 span 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 span 标签，然后找到 span 标签上的 a 标签，最后再去找到 div 标签，然后给符合这种条件的 span 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写过于具体的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证层级扁平。

将动画效果应用到position属性为absolute或fixed的元素上，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 requestAnimationFrame，详见探讨 requestAnimationFrame。

避免使用CSS表达式，可能会引发回流。

将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点，例如will-change、video、iframe等标签，浏览器会自动将该节点变为图层。

CSS3 硬件加速（GPU加速），使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

JavaScript

避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。