##### 1.shadowDom
&emsp;&emsp;启用shadowdom，shadowdom是一个dom节点，根为shadowroot，可以使用 Element.attachShadow() 方法来将一个 shadow root 附加到任何一个元素上。shadowdom内部和外部是隔离的，互不影响，但是能够拿到shadowdom的dom节点。
```javascript
let div = document.getElementById('__qiankun_microapp_wrapper_for_vue_app__');
let shadow = div.attachShadow({mode: 'open'});
let shadowDom = shadow.shadowRoot
```
> 使用shadowDom做样式隔离的问题：子应用使用elementui中msgbox这类组件，其dom是追加在body元素上的，但是其样式是写在shadowdom内部，导致样式拿不到而错乱，同样的，子应用中一个弹窗实现居中，也难以实现，这一点和iframe是一样的。

##### 2.postcss-selector-namespace 子应用样式添加命名空间
>和shadowDom有同样的问题，相当于和主应用样式做了完全隔离，但是插入body的dom结构样式丢失

```
npm i postcss-selector-namespace -D
```

.postcsssrc.js
```javascript
module.exports = {
  "plugins": {
    "postcss-import": {},
    "postcss-url": {},
    // to edit target browsers: use "browserslist" field in package.json
    +'postcss-selector-namespace': { namespace: '.custom-namespace' },
    "autoprefixer": {}
  }
}
```


##### 3.为主应用样式添加scoped或css-module，同时修改elementui等插件的样式前缀
通过这种方式可以做到样式和子应用互不污染
```
npm i change-prefix-loader postcss-change-css-prefix -D
```
>change-prefix-loader用于替换js（js最终生成dom）中的前缀，postcss-change-css-prefix用于替换样式中的前缀

.postcsssrc.js
```javascript
module.exports = {
  "plugins": {
    "postcss-import": {},
    "postcss-url": {},
    // to edit target browsers: use "browserslist" field in package.json
    +'postcss-change-css-prefix': {prefix: 'el-', replace: 'parent-el-'},
    "autoprefixer": {}
  }
}
```
webpack.config.js
```javascript
{
  test: /\.js$/,
  loader: 'change-prefix-loader',
  include: path.resolve(__dirname, '../node_modules/element-ui/lib'),
  options: {
    prefix: 'el-',
    replace: 'parent-el-'
  }
}
```

