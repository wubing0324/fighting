<!--
 * @Author: wubing32696 wubing32696@hundsun.com
 * @Date: 2023-02-23 19:30:55
 * @LastEditors: wubing32696 wubing32696@hundsun.com
 * @LastEditTime: 2023-02-26 16:30:22
 * @FilePath: \biji\面试准备.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->

vue2:
vue2源码：
slot，
keepalive，
响应式原理，√
组件注册:全局注册：遍历asset_types取到component生成Vue.component方法，最后根据传入的vue对象返回一个构造函数，存储在options上。局部注册是合并到子组件的options上。√
diff算法，√
computed，√
watch，√
钩子函数执行顺序和子组件解析的流程 √
vue-router源码,使用vue-router做路由级缓存
vuex源码
大数据虚拟列表原理
element-ui如何实现组件（table，msgbox）
vue.extend用法
vue-loader，vue-template-compiler
i18n原理
css3动画
less/scss，变量，换肤
jwt加密token
打包后dom标签之间会出现空格问题

webpack多入口打包，异步chunk id冲突问题
vue3：响应式原理，diff算法，和vue2的区别

微前端：singlespa原理，乾坤原理，如何存储全局对象，样式隔离和卸载，为什么要用微前端

typescript用法

eslint，git

性能优化，加载白屏问题，减小包的体积
webpack原理：complation和compiler，module，graph算法，webpack优化性能，什么是loader，实现一个loader。什么是plugin，实现一个plugin。webpack中按需加载的实现
publicPaths是什么
node中require的实现，cmd，amd
rollup使用

javascript基础：什么是this，实现一个软绑定，实现一个new方法，原型链，防抖和节流、深拷贝
es6：promise实现，async/await，跨域
实现一个ajax

正则表达式：

移动端适配

浏览器解析原理

dns，http，缓存，nginx

html：盒模型，flex布局

npm包知识

、
工作中遇到的问题：

vue3子应用嵌入qiankunjs，子应用的main.ts中createApp需要每次mount都创建一个实例，否则子应用不会加载

canvas和swiper联合使用，canvas内容为空，因为swiper循环滚动需要复制dom，但是如果复制内容是canvas，则为空，解决办法，在复制的dom中也绘制一遍chart，通过class来渲染echart

用await写promise，错误处理需要放在try catch中，否则下面的代码不会执行
webpack异步加载模块

将echarts生成图片，插入到wangEditor，再把可编辑文本生成pdf，dom内容会被分割在不同页，尤其是图片被分割，通过遍历每个元素，根据offsetTop和offsetHeight来判断元素是否在分割处，如果是，追加空的dom。

$attrs和$listerners在使用render的时候，需要显示传入


下拉框异步回填（返回数据后默认选中第一项）:输入框会设置防抖200ms，输入1发请求，在过了200ms但是请求还没返回的时候，输入了2，紧接着1的请求返回了，就会回填到输入框中，导致第二次请求被取消，因为这些都是在第二个200ms之内的。
解决办法：自己实现简单防抖，把timer句柄定义在vue.options.data上，也就是全局的，然后每次节流的函数执行（在请求发起但是还异步没有成功的时候），把timer清空，当请求成功执行回填的逻辑的时候，判断一下当前的timer是不是不为空，如果不为空说明还有新的定时器，那么本次的结果就不执行回填，等待下一次请求的结果回来再回填。
```javascript
function debounce(fn, time){
  var timer = null;
  return function () {
    var self = this
    var args = arguments
    if (timer) clearTimeout(timer)
    timer = setTimeout(function(){
      console.log(args)
      fn.apply(self, args);
    }, time)
  }
}
// 节流和防抖：
// 原理：settimeout和setinterval的执行会返回一个正整数（大于0的整数）作为句柄，一般我们叫它timer，利用timer，我们知道当前是否有定时器在执行，
// 节流：如果有timer，那就清空这个timer，对应的定时器和回调函数也就被取消了。然后定义新的timer，这样就可以达到在一定的时间间隔内连续蓄发某个函数，只有最后一次的生效
// 防抖：如果timer有值，说明上一次的函数还没有执行完毕，所以直接返回。当本次timer对应的方法执行完毕，清空timer。

// 注意：settimeout和setinterval最大时间大约是24.8天，超出这个值会立即执行

```
qiankun:子应用嵌入主应用,子应用中又嵌入了iframe,iframe不能写相对路径'./'

tofixed精度问题

import()方法问题

弹窗打开快速关闭再打开，由于异步的问题，导致弹窗内表格无法打开


rollup打包：插件版本之间不兼容问题，"@rollup/plugin-commonjs" requires at least @rollup/plugin-node-resolve@13.0.6.

排除法发现rollup-plugin-vue@4.7.2打包的时候会始终卡在created而不结束，升级到6.0.0即可

module-app模式

行内元素间的换行符导致出现空隙。Vue用删除标签间换行符解决。产生这个问题的原因在于，a 标签间的空格和换行符被解析成文本节点，产生了空隙。当然，在源代码中删除 a 标签间的空格和换行是可以解决此问题。但是代码格式难以阅读。webpack.config.js配置文件中，对vue-loader加入preserveWhitespace: false 就可以了。

表格排序字段和显示字段不一致导致的排序问题


webpack异步加载原理

table实现

ts

js沙箱

研发中心提供外框，每个子系统以模块的形式存在，每个子系统对外暴露一个index,js,这个文件将作为webpack打包的入口，将子模块打包成umd格式的库，其中导出自己的路由信息（菜单：文件路径），组件，store，然后在外框url发生变化的时候，根据菜单中的子系统号和菜单编号，获得对应的子系统资源，通过addroutes加载对应的子系统信息和界面。
而我们对于外框又添了自定义的样式，和功能（消息盒子，跑马灯），业务很多功能也由外框来实现，导致外框越来越大，逻辑过于复杂，难以维护。所以改造为微前端框架，每个业务子系统变成一个独立的项目，维护各自的功能。而之前遗留的通用功能，就需要抽成一个插件，需要的业务子系统子系统去引入。
改造过程中，研发中心框架并不完善，我的主要责任就是尝试改造子系统，汇总遇到的问题，和研发中心商讨如何解决，由谁来解决。
例如：1.0中，各模块之间的界面通过路径是可以相互引用的（既可以通过网络加载整个资源，然后使用其中的某个资源，通过网络有一个弊端，又可以直接开发的时候就写相对路径来引用资源），因为是在同一个项目下，系统a加载系统b的资源，各自独立后，就无法引用了，最后商讨方案是 在子系统的webpack配置中，定义需要被其他系统引用的资源，单独定义那些需要被外部引入的资源，
1.0和2.0优缺点对比：
1.0
弊端：
随着个性化功能的越来越多，代码越来越复杂，难以维护，有些子系统并不需要这些功能
研发中心框架更新，我们需要合并修改框架对应的代码
所有子系统依赖的第三方库都在同一个外框中，即便可以使用external做成外部链接，但是针对这么多子系统，如何维护哪些是需要external的呢
子系统嵌入客户端的时候，许多不必要的依赖导致包体过大，加载缓慢，同时需要去掉外框中leftbar，topbar等内容
优点：
依赖一次性加载完后，子系统的加载速度快，所以只有首开比较慢
部署的配置比较简单

2.0
弊端：
每个子系统都会打包自己的依赖，包体积变大
部署配置比较复杂，需要改动代码结构，添加路由前缀适配微前端的主应用
优点：
去掉了外框上那些不属于自己的功能，代码逻辑清晰
可以自定义依赖包的版本
嵌入客户端更加便捷，不需要再使用条件判断去掉一些多余的dom结构
不需要投入精力再去维护一个外框，只需要维护一个简单的插件即可


入职的是资管部门，主要负责通用组件维护（研发中心实现的组件的基础上，封装了业务逻辑，产品组合单元操作员，大数据表格简单表格，先做一层数据处理，转成他们需要的格式，在通过props传给他们），但是当时刚好架构办和研发中心在推微前端改造，先拿资管开刀，所以我就先去做了微前端改造，1.0系统大致结构是：子系统作为资源被使用，每个子系统提供一个index.js，导出自己的路由表（菜单：文件路径），组件，store等信息通过webpack配置，打包成一个umd库，路由首位beforeeach中根据url的变化获取对应的菜单信息，再通过菜单信息中的子系统号加载子系统资源，在通过菜单编号拿到界面对应的路由信息通过addroutes生成路由表。
对这个外框的个性化需求（样式主题、消息盒子、跑马灯。。。）需要单独维护，
a系统引入b系统的一个界面，需要加载a系统的整个资源，或者开发的时候直接通过路径引入那个界面



组件封装原则

项目中的亮点：
+ 1.0中使用多入口打包生成多个子系统umdjs，但是当分开打包子系统模块，又在a系统引入b系统的一个界面，可能会出现异步加载的模块id重复而导致b的界面无法加载的问题，使用import（）来修改打包模式
+ 在抽离的插件中，使用postinstall修改了local_config的属性
+ 重构了组件打包方式，和下拉框组件
+ 发包频繁，无法确定以来的h_ui或者通用组件库的版本，虽然每个包可以自己定义更新的版本，但不是每个包都会这样做，并且在主子应用同时使用同一个包的时候，无法确定包的版本，在打包时通过
definePlugin定义全局属性，将package-lock.json中dependices的版本信息存储起来
+ 解决了主子应用样式隔离的问题
+ 解决了一些bug：表格排序字段和实际现实的字段不一致的问题，因为业务自己做了翻译的逻辑；下拉框节流回填导致的问题；在大数据表格和下拉框中，展示的内容是遍历对象通过其中某些字段拼接而成的，相当于先遍历数据列表，在遍历对象的每个字段。多了一层循环，时间复杂度是n * m，对象的字段越多，m越大。return obj.a + obj.b,通过new Function('obj', return obj.a + obj.b)将这一过程自动化，return obj.a + obj.b，这个拼接的过程通过reduce方法来实现。
自己的亮点

基础知识（盒模型，flex）

有没有实现过loader

plugin呢

axios原理
CSRF 和xss


毕业于东北农业大学，目前做了7年前端，使用过jquery、css3、photoshop、angular、electron，rollup、gulp，从吉利到恒生的五年一直在使用vue技术栈和webpack，了解vue技术栈和webpack的实现原理，在恒生的主要工作分为前后两部分，第一部分负责微前端改造，项目周期十个月，主要职责是对子业务代码进行改造以接入主应用.
第二部分负责资管通用组件开发和维护，项目周期一年半，银信组件开发和组件代码合并，重构。主要职责功能开发和代码合并，代码重构和bug修复。在恒生解决了大大小小200多个bug。

在吉利重构了移动端的项目，主要职责是pc和移动端bpm流程管理系统的维护和开发

在吉利主要是和部门内部同事进行合作开发，包括产品经理、设计、后端和测试，在恒生跨部门协作的情况居多，日常工作是帮业务开发排查定位问题，完成他们提出的需求，如果bug是研发中心的需要和研发中心沟通，商定解决方案和发布日期。

在有很强的驱动力的情况下，我可以快速学习新知识，然后投入到工作中，入职第二家公司，第一次接触angular，经过一周的学习和代码熟悉，我就可以完成领导分配的任务。在吉利使用electron，在恒生做微前端改造，都是从零学起并快速掌握。

如果可以入职中汇，我相信我可以快速融入大家并且胜任自己的工作，在完成领导安排的任务的前提下，我希望我可以发现项目中的痛点并且和大家一起解决这些问题。



vue2和3的区别：
1.函数时api和组合式api
函数时api和组合式api的对比：
函数时方法必须写在methods中，响应式数据必须写在data中，当一个组件中有两个或更多功能时，他们是交织在一起的，
而setup函数中可以在任意位置定义响应式数据和方法，同意功能的代码可以放在一起，便于理解和调试。

2.新增setup函数，对ts支持更好，兼容vue的函数式api

3. 2的响应式必须在data中定义，尤其是  对于对象，在data之外定义的对象的属性不是响应式的，不需使用set才可以。
vue对于对象类型的数据，使用proxy对象来设置响应式，也就是依赖收集和绑定effect，并且响应式的创建是按需的，所以性能也就更好。

4 hooks: 得益于响应式的设计，可以在任意位置定义响应式数据，所以有了hooks。代码复用更加便捷，比minix更加清晰。当然，vue2中也能实现类似hooks的功能：
```javascript
// utils/hooks.js
import Vue from 'vue';

export function useCounter() {
  const state = Vue.observable({
    count: 0
  });

  function increment() {
    state.count++;
  }

  function decrement() {
    state.count--;
  }

  return {
    state,
    increment,
    decrement
  };
}

```
vue2是通过闭包和definepropety来 存储每个响应式数据的dep，而vue3定义了全局的depmap和proxy来实现响应式。

