<!--
 * @Author: wubing32696 wubing32696@hundsun.com
 * @Date: 2023-02-23 21:10:59
 * @LastEditors: wubing32696 wubing32696@hundsun.com
 * @LastEditTime: 2023-02-23 21:11:12
 * @FilePath: \biji\vue2\事件.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
// vue到底是如何区分自定义事件和原生事件的,其实有两种情况,生成ast树和generate是无差别的,也就是生成
  // render的过程是无差别的,直到createElm,会根据标签tagName来判断到底是组件还是原生dom,然后就有了区分.
  // 这是其中一种:
  // _c('div',{attrs:{"id":"app"},on:{"click":change}},[_c('input'),_v(" "),_c('button-counter',{on:{"myclick":myClick}}, native: {click: handleClick})],1),
  // 'button-counter'就是子组件,他的on属性上的事件自然就是自定义事件,因为非html标签上不能定义原生事件,除非是另一种情况: .native修饰符

解析完成后，on对象中的事件会有两种处理方式：组件和原生dom

在创建vnode的 过程中，如果是组件，listeners最终会传给$on,执行如下代码：
```javascript
function createComponent (
    Ctor,
    data,
    context,
    children,
    tag
  ) {
...
    data = data || {};
    // extract listeners, since these needs to be treated as
    // child component listeners instead of DOM listeners
    var listeners = data.on;
    // replace with listeners with .native modifier
    // so it gets processed during parent component patch.
    data.on = data.nativeOn;
    var vnode = new VNode(
      ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
      data, undefined, undefined, undefined, context,
      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
      asyncFactory
    );
    return vnode
  }

opts._parentListeners = vnodeComponentOptions.listeners;
```

之后所有的data.on事件都是原生事件了：
```javascript

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}
```
  // 生成组件的vnode,同时挂载组件的钩子函数