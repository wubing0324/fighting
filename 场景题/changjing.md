
https://github.com/OBKoro1/web-basics
https://juejin.cn/post/7174241429990932488
https://www.nowcoder.com/discuss/353158686656897024
https://github.com/OBKoro1/web-basics/blob/main/src/scene/template.js

##### @说一说你最近的项目；

+ 记叙文的六要素：时间、人物、地点、起因、经过、结果；
+ 时间：立项时间，研发周期；
+ 人物：团队成员、分工、我负责哪几个模块；
+ 起因：项目背景、项目的用户是谁、用户能用这个App干啥、基本业务逻辑描述；
+ 经过：我负责哪几个模块，主用的技术栈是...，
+ 结果：1.0耗时多久上线、目前处于何种状态；
+ 项目亮点：最好有并且输出10分钟，例如组件封装、逻辑复用、性能优化、权限控制等；

##### @你的项目是怎么做的权限管理的？（背之~）

使用经典的 RBAC策略，也就是所谓的基于角色的权限控制策略去做；
分四个层面去做权限控制，分别是接口层、菜单层、路由层、组件层；
接口层主要通过axios的响应拦截器去做；
当用户访问一个未授权的服务端接口时，通常服务端会返回一个401或403的状态码，我们在axios响应拦截器中可以做相应处理，例如返回一个毁约态的Promise对象，或者直接帮应用程序跳转登录页或者未授权页等；
如果说想在前端直接做一些过滤，帮后台减轻一些访问负担的话，我们可以在axios的请求拦截器中判断当前用户是否有对当前接口的访问权限，如果没有也返回一个毁约态的Promise对象或者暴力跳转登录页或者未授权页也可以——最好还是交给应用层自己去跳转，或者至少以配置的方式告知axios该往哪里跳，以便视图层和数据层的解耦；
这是所谓接口层权限控制；
接下来是菜单层：当用户登录以后，可以由服务端返回一个对应的权限菜单，然后我们在主页中来动态渲染这个权限菜单；
我有封装过一个递归菜单组件，所以做起来还算比较方便！
如果用户在没有菜单项的情况下暴力输入路由地址的话，会直接跳转404页面，具体实现由路由层权限来加以控制；
路由权限在四层权限控制里相对复杂一些，可以分为全路由表策略和半路由表策略两种实现方式——名字是我自己起的，不好意思~
所谓全路由表策略，就是直接在前端挂载全部用户可能用到的路由，然后通过路由守卫去控制访问权限；
在Vue中实现起来很方便，因为Vue自带路由守卫机制，我们只需要在每个路由的声明里加一个meta信息，标记当前路由的授权访问角色列表就行了，没权限的时候一脚踹到登录页或者404页面都可以；
React里的路由守卫需要自己封装，我的做法是基于react-router-dom的Route组件做二次封装形成一个名为AuthedRoute的组件，除了接收Route组件需要的path和component属性以外，还额外接收一个roles（肉丝儿）属性用以声明当前路由的授权访问角色列表，再另外接收一个roleGetter属性，值是一个函数，调用一下就能获取当前登录用户的角色，最终在AuthedRoute组件挂载的时候，调用roleGetter函数去获取当前登录用户的角色，然后跟roles肉丝儿列表进行比对，有访问权限就渲染跳转目标Route，没权限就渲染一个跳转404的Route；
这是所谓全路由表策略；
另外一种就是所谓的半路由表策略，程序加载的一开始只挂载几个公共路由，登录页、关于页什么的；
用户登录成功以后，后台返回一个权限路由表的JSON数据，然后前端解析一下，根据解析结果把权限路由一个一个地router.addRoute进去，在路由表的最后挂载一个通配的404路由；
这样当用户暴力在地址栏输入非法路由时，无法命中任何一个公共路由或权限路由，就会最终命中404！
这就是我所谓的半路由表策略；
最后是组件级别的权限控制，比如一个按钮什么的，最简单粗暴的做法就是使用条件渲染，if有权限就显示，否则就不显示；
如果要封装一下的话，我的实际操作是，在Vue中封装一个v-auth指令，放在要鉴权的组件身上，值是一个对象，内含roles肉丝儿可访问的角色列表，外加一个roleGetter函数，在组件或者指令挂载的时候调用roleGetter获取当前用户的登录角色与roles肉丝儿进行比对，如果有权限就什么都不做，也就是正常渲染当前组件，否则就是没权限，直接el.remove()把当前元素给删除，用户就什么都看不见了！
在React当中我的做法是封装一个Auth包装器组件，将要鉴权的组件放在Auth组件的肚子里，Auth组件同样接收roles肉丝儿和roleGetter两个props，权限匹配就正常返回chilren这个JSX，没权限就返回空气 / 幽灵标签，用户实际就什么都看不到了！


##### @组件封装整体思路（背之~）

以终为始，想想用户怎么用起来是最趁手的，我们的组件就怎么去设计；
无非管理好几样东西：
父组件需要告诉子组件一些什么信息，无非数据长啥样，配置长啥样；
子组件需要回传哪些信息给父组件，比如用户点击了确定，父组件我作为儿子我把这个情报告诉你了，具体怎么处置您看着办，例如用户在儿子身上点击了某个item，作为儿子的我把这个item的序号和负载的数据都告诉父亲大人您了，您看着处置吧——管理好回调和子父通信；
写在组件肚子里的模板/JSX，不管是叫插槽还是叫children，通常都是一部分需要特殊排版的DOM结构，组件拿过来要怎么渲染一下；
最后组件需要暴露哪些特定的API出来给父组件，以便父组件做整体的调度；

##### @万用表格封装思路（背之~）

以终为始，先构思好用户怎么用着爽，我的props和相应API就怎么去设计
就表格而言，用户需要传入数据
用一个props(formatter)描述一些特殊的字段要如何显示，例如头像avatar显示为一个a标签嵌套img来显示，再例如用户昵称也显示为一个a标签嵌套昵称的文本
用一个数组告诉表格哪些字段可以支持排序
这样表格逻辑大致就是：
首先使用列表渲染将data数组映射为一组div即表格行
行内再继续列遍历一个item的所有字段，一一映射为列div，也就是表格的单元格了
每个单元格内默认显示对应字段的值
但如果formatter/props告知这个字段要渲染为a标签或img或其它用户自定义的JSX形式，就按用户告知的来
哪些字段支持排序，就在点击对应的列表头时使用arr.sort对数据进行排序，然后直接定位回第一页
主要的state有dataArr为总数据，pageArr为当前页数据，currentPage即当前页码
使用useEffect监听currentPage的变化，然后从dataArr中截取对应页的数据去更新pageArr
表格本质显示的是pageArr
最后表格对外暴露出setCurrentPage/API，供外界去调用实现翻页，主要的调用者其实是分页器组件

##### @万用表单封装思路（背之~）

核心props肯定是表单要显示的数据对象了
表单标题、表单宽度、点击确定后的回调，也都由父组件以props形式注入
既然叫万用表单，言下之意就是用户可以自定以每个数据字段在表单中的展示和编辑方式
我是用一个名叫dataFrame也就是数据框架的props来接收用户对表单布局的描述
这个props的标准格式是一个二维数组
每个内层数组描述表单的一行
每个内层数组item描述一个单元格里要展示的表单控件
该item的核心属性包括label、type也就是何种控件（核心类型无非是text、password、select、textarea），如果type是select的话还需要额外带一个optionValues属性例如东南西北，核心属性还有key，代表当前表单控件显示formData的哪个key
item的核心属性还有rowSpan，colSpan描述跨行跨列排版配置，根据这个二维数组的每个最内层item的描述，就可以绘制一个自定义排版的table表格，每个单元格内都是一组label+表单元素组合
当type是textarea时，展示控件为一个富文本编辑器
我的万用表单还支持type是form类型，也就是说该万能表单是支持递归的——万用表单的JSX里还有万用表单
如果父组件给一个editable=false，那么该表单仅仅只是一个数据展示组件，所有表单元素都有disabled属性，用户不可编辑，表单的最后一行也只有一个返回按钮
如果父组件给的editable=true，则传入的formData在表单内会形成一个state，各表单元素的onChange事件都会形成一次setState或setFormData
在可编辑模式下，当用户最终点击了确定按钮时，会回调父组件传入的onConfirm函数，将最新修改的表单数据state通知父组件
对于text、textarea和password组件，onChange事件是加过防抖优化的
所以最终我这个万用表单可以展示或编辑任意数据，并且以任意格式去排版，并且用户的最新修改会回调通知给父组件进行任意的后续操作

##### @递归菜单封装思路（背之~）

递归菜单组件接收的核心props就是一个menu数组
每个item代表一个菜单项，有icon,text,path也就是跳转路由地址
根据这个item的描述就可以轻而易举地绘制一个不可展开的基础菜单项，点击时跳转对应路由
如果这个item中有一个submenu属性，就意味着当前菜单项是可以展开的
就继续递归submenu中的二级item，渲染时缩进一个层级
以此类推，可以做出无限层级的递归菜单
说说icon解决方案：
icon的值是个字符串，会渲染出一个MyIcon组件，接收一个name，然后从font-awesome经典图标库中检索出对应图标字体
再说说纵横折叠解决方案：
菜单接收一个singleExpand属性，默认为true，也就是说允许同时展开所有子菜单，设置为false时，每次只允许展开一个子菜单，其余自动折叠
具体实现方式为：用一个currentExpand/state来描述当前展开的是第几项，如果一级菜单项的index不为currentIndex时，则菜单收起
水平折叠方式为，宽度通过transition动画逐渐收缩为5rem，收缩过程中的overflow为hidden，收缩动画完成后切换到折叠模式，菜单项都变为各自的图标即可

##### @大文件上传组件封装思路（背之~）
手摸手来封装一个大文件分片上传组件何如

组件布局一个type等于file的input元素，外加一个上传按钮就OK了；
当用户选择了文件以后，用一个state把用户选好的文件e.target.files[0]存起来；
这个state是一个File类型的数据，本质就是一个字节数组，后续可以直接对它进行切片；
选好文件，点击上传，就开始进入切片上传逻辑；
通过file.slice将文件切割为一堆分片/chunk，分片的类型自然还是字节数组；
将分片数组映射为Promise数组，使用axios向服务器接收地址发送POST请求，通过手动构造的FormData数据携带每个分片的字节数据和序号，此时所有分片已经开始了上传动作；
通过Promise.allSettled以刚刚的Promise数组为入参，分别获得每个切片的上传结果；
对于上传成功的分片，文件上传的整体进度+1，对于失败的分片进行重传；
服务端接收接口是父组件以props形式传入的；
服务端的操作无非就是逐个接收，最后再重新拼接为文件；
大致如此，难度还好~


@弹窗封装思路

@axios的封装思路；

@某hook的封装思路；
以【获取页面组件的实时滚动位置钩子useScroll】为例：

该组件能实时获取页面的滚动位置，即调用useScroll()会到响应式数据scrollTop;
hook内要定义响应式输入const scrollTop = ref(0)；
需要将真正在滚动的元素作为参数传递给该hook：const scrollTop = useScroll(scrollingElement)
组件挂载时对其根元素添加scroll事件，组件卸载时移除该DOM事件监听器，以避免内存泄露；
在scroll事件监听器中，实时获取根元素的scrollToP，同步给ref数据scrollTop：

js复制代码const scrollHandler = (e) => {
    scrollTop.value = root.scrollTop
}


最终调用该hook的组件得到的就是其根元素实时滚动的位置这一响应式数据，其余的什么都不用管；

@某指令的封装思路；

v-change指令可以在元素被鼠标覆盖的时候改变样式，鼠标移出的时候恢复默认样式；
使用方式：

html复制代码<button v-change="{color:'cyan'}">Click Me</button>


指令作用的目标元素所在的组件被挂载时，创建mouseover事件侦听，在其内部将应用binding.value定义的所有样式，在应用该样式之前，要先缓存在元素变化之前的样式在指令对象的defaultStyle中；
同时注册该元素的mouseout事件侦听，在其中恢复事先缓存好的该元素的默认样式；
指令作用的目标元素所在的组件被卸载时，移除该元素的mouseover与mouseout事件侦听；

作者：搬砖的乔布梭
链接：https://juejin.cn/post/7174241429990932488
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。