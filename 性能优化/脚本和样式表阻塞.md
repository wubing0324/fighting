script的加载和执行都会阻塞html的解析和渲染
对于不带src的脚本，可以通过异步分片的方式优化渲染

对于带src的script，可以添加defer和async属性，让脚本的加载和执行不再阻塞html解析和渲染

defer：多个defer的脚本按引入顺序执行，不按加载完毕顺序执行
async：加载完立即执行
domcontentloaded和load的区别:
domcontentloaded是dom构建完成（html解析成dom、defer、domcontentloaded）
load是样式表和图片加载完成
为什么script标签要放在html的底部：
web模型是同步的，html的解析是从上到下的，当遇到script标签回去下载和执行脚本，此时html的解析被暂停，scriopt标签可能会操作dom，放在底部可以确保html已经解析成dom，只是还没渲染
```javascript
// 会解析dom，但是永远不会渲染
<body>
  <div id="test">jhkhjklhjkhjk</div>
  <div>jhkhjklhjkhjk</div>
  <div>jhkhjklhjkhjk</div>
  <div>jhkhjklhjkhjk</div>
  <div>jhkhjklhjkhjk</div>
  <div>jhkhjklhjkhjk11111</div>
  <script>
    let i = 0
    while(true){
      i++
    }
  </script>
```

```javascript
// html解析生dom从上到下，所以test为null
<script>
  let test = document.getElementById('test')
  console.log('test = ', test) // null
</script>

<div id="test">jhkhjklhjkhjk</div>
<div>jhkhjklhjkhjk</div>
<div>jhkhjklhjkhjk</div>
<div>jhkhjklhjkhjk</div>
<div>jhkhjklhjkhjk</div>
<div>jhkhjklhjkhjk11111</div>
<script>
  let test1 = document.getElementById('test')
  console.log('test1 = ', test1) //div
</script>
```

##### 脚本
Web 的模型是同步的。作者希望解析器遇到 < script> 标记时，能立即解析并执行脚本。 文档解析将停止，直到脚本执行完毕。如果脚本是外部的，则必须先从网络中提取资源 - 此操作也是同步完成的，解析会停止，直到提取资源为止。 此模型已经使用了多年，并且还在 HTML4 和 HTML5 规范中进行了指定。 作者可以向脚本中添加“defer”属性，这样它就不会停止文档解析，而是在文档解析完成后执行。HTML5 添加了一个选项，用于将脚本标记为异步，以便由其他线程解析和执行。

##### 推测解析
WebKit 和 Firefox 均会执行此项优化。在执行脚本时，另一个线程会解析文档的其余部分，找出并加载需要从网络加载的其他资源。通过这种方式，可以在并行连接上加载资源，从而提高整体速度。注意：推测性解析器仅解析对外部资源（如外部脚本、样式表和图片）的引用：它不会修改 DOM 树，而 DOM 树留给主解析器的引用。

##### 样式表
另一方面，样式表采用不同的模型。从概念上讲，由于样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但存在一个问题，那就是脚本在文档解析阶段会请求样式信息。如果样式尚未加载和解析，脚本将获得错误答案，这显然导致了很多问题。 这似乎属于极端案例，但其实很常见。如果存在仍在加载和解析的样式表，Firefox 会阻止所有脚本。 只有当脚本尝试访问可能会受未加载的样式表影响的特定样式属性时，WebKit 才会阻止脚本。
CSS 是否阻塞 HTML 的解析？
通过页面渲染的流程图我们可以看出 HTML 和 CSS 浏览器是可以并行解析的，也就是说外联 CSS 的加载和解析并不会阻塞 HTML 的解析，不过在 HTML5 标准中增加了一项规定，那就是浏览器在执行 script 脚本之前必须要确保该脚本之前的外联 CSS 已经加载解析完成，首先我们先想想这样做的目的是什么？
比如在 sript 脚本中我们可能会调用 getComputedStyle 等方法获取对应的 DOM 元素样式，如果在该脚本之前的外联 CSS 还没有被加载解析好，那么获取到的样式可能就是不准确的，所以在 HTML5 版本中才有了这个规定
这样一来，CSS 是否阻塞 HTML 解析这个问题可能就变得复杂了。如果某个外联 CSS 后面并没有任何 script 标签，那么还是像我们之前说的答案一样，该外联 CSS 的加载解析并不会阻塞 HTML 的渲染；但是如果该外联 CSS 后面有 script 标签，当解析到 script 标签时，js 文件虽然可以和 CSS 文件一起并行加载，但是 js 必须要等到 CSS 文件加载解析完成后才能执行，又因为 js 的执行在大部分情况下都会阻塞 HTML 的解析，相当于 CSS 通过阻塞 js 的执行来间接阻止了 HTML 的渲染

##### 预加载扫描器
预加载扫描程序是一种浏览器优化，采用辅助 HTML 解析器的形式，可扫描原始 HTML 响应，以找出并推测性地提取资源，然后主 HTML 解析器才会发现这些资源。例如，即使 HTML 解析器在获取和处理 CSS 和 JavaScript 等资源时阻止了 HTML 解析器，预加载扫描程序也会允许浏览器开始下载 <img> 元素中指定的资源。

为了充分利用预加载扫描器，服务器发送的 HTML 标记中应包含关键资源。预加载扫描器无法发现以下资源加载模式：

由 CSS 使用 background-image 属性加载的图片。这些图片引用位于 CSS 中，预加载扫描器无法发现这些引用。
动态加载的脚本，采用 < script> 元素标记（使用 JavaScript 注入 DOM）或使用动态 import() 加载的模块。
使用 JavaScript 在客户端上呈现的 HTML。此类标记包含在 JavaScript 资源的字符串中，预加载扫描器无法发现此类标记。
CSS @import 声明。
这些资源加载模式都是后来发现的资源，因此无法从预加载扫描器中受益。请尽可能避免。但是，如果无法避免此类模式，您或许可以使用 preload 提示来避免资源发现延迟。
避免使用 CSS @import 声明
虽然这看起来似乎很方便，但您应避免在 CSS 中使用 @import 声明：
```javascript

/* Don't do this: */
@import url('style.css');
```
与 <link> 元素在 HTML 中的工作方式类似，CSS 中的 @import 声明允许您从样式表中导入外部 CSS 资源。这两种方法的主要区别在于，HTML <link> 元素是 HTML 响应的一部分，因此会比通过 @import 声明下载的 CSS 文件更早地被发现。

这是因为，为了让系统发现 @import 声明，必须先下载包含该声明的 CSS 文件。这会产生所谓的请求链（就 CSS 而言），请求链会延迟网页首次呈现所需的时间。另一个缺点是，预加载扫描器无法发现使用 @import 声明加载的样式表，因而会延迟发现会阻塞渲染的资源。
```javascript
<!-- Do this instead: -->
<link rel="stylesheet" href="style.css">
```
>注意：如果您需要使用 @import（例如用于级联层或第三方样式表），可以通过对导入的样式表使用 preload 指令来缩短延迟。此外，CSS 预处理器（例如 SASS 或 LESS）通常使用 @import 语法来改进开发者体验，从而提供单独的、更加模块化的源文件。不过，当 CSS 预处理器遇到 @import 声明时，引用的文件会捆绑并写入单个样式表中，从而避免 @import 在普通 CSS 中导致的连续请求惩罚。

##### 内嵌关键 CSS
下载 CSS 文件所需的时间可能会增加网页的 FCP。在文档 <head> 中内嵌关键样式可以消除对 CSS 资源的网络请求，并且如果操作正确，可以在用户的浏览器缓存尚未准备好时缩短初始加载时间。其余 CSS 可以异步加载，也可以附加到 <body> 元素的末尾。
性能优化总结：
图片压缩
js、css压缩
缓存
coverage去掉无用或首屏不用资源、延迟加载他们以提高首屏速度
dns-prefetch
preconnect
cdn：
内容分发网络 (CDN)
内容分发网络 (CDN) 是分布式服务器网络，服务器从源服务器缓存资源，反过来再从物理上更靠近用户的边缘服务器传送资源。在距离用户较近时，可以缩短往返时间 (RTT)，而 HTTP/2 或 HTTP/3、缓存和压缩等优化技术则可以让 CDN 更快地提供内容，而不是从源服务器提取内容。在某些情况下，使用 CDN 可以显著改善网站的 TTFB。
减少重定向

如何高效加载第三方脚本？
如果第三方脚本拖慢了网页加载速度，您可以通过以下几种方式来提高性能：

使用 async 或 defer 属性加载脚本，以免阻止文档解析。
如果第三方服务器速度缓慢，请考虑自行托管脚本。
如果脚本没有给您的网站带来明显的价值，请将其移除。
使用 <link rel=preconnect> 或 <link rel=dns-prefetch> 等资源提示对托管第三方脚本的网域执行 DNS 查找。
使用 async 或 defer
JavaScript 执行会阻塞解析器。当浏览器遇到脚本时，必须暂停 DOM 构建，将脚本传递给 JavaScript 引擎，让脚本执行完毕，然后再继续构建 DOM。

async 和 defer 属性会以如下方式更改此行为：

async 会导致浏览器在继续解析 HTML 文档时以异步方式下载脚本。脚本下载完成后，解析会在脚本执行期间阻止。

defer 会导致浏览器在继续解析 HTML 文档时以异步方式下载脚本，然后等待脚本解析完成。

始终对第三方脚本使用 async 或 defer，除非该脚本对于关键渲染路径是必需的。如果脚本在加载过程的早期阶段必须运行（例如，对于某些分析脚本），请使用 async。对于不太重要的资源，例如在网页上呈现的速度低于用户最初会看到的视频，请使用 defer。



性能指标：
performance
web-vitals
lighthouse
WebPageTest 